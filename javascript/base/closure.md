## JavaScript闭包
JavaScript变量可以是局部变量或者全局变量。
私有变量可以用到闭包。

### 全局变量
变量声明时如果不适用var关键字，那么它就是一个全局变量，即便它在函数内定义。

局部变量只能定义于函数内部。对于其他的函数或脚本代码是不可用的。
全局变量和局部变量即使名称相同，他们也是两个不同的变量。修改其中一个，不会影响另一个的值。

### 变量生命周期
全局变量的作用域是全局性的，即在整个JavaScript程序中，全局变量处处都在。
而在函数内部声明的变量，只在函数内部起作用。这些变量是局部变量，作用域是局部性的；函数的参数也是局部性的，只在函数内部起作用。

### 计算器的困境
设想一下如果你想统计一些数值，且该计数器在所有函数中都是可用的。
你可以使用全局变量，函数设置计算器递增：
```
var counter = 0;
function add() {
  return counter += 1;
}

add();
add();
add();
// counter == 3
```
但是问题来了，页面上的任何脚本都能改变计数器的值，即使不调用add()函数。
如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值：
```
function add() {
    var counterer = 0;
    counterer += 1;
}

add();
add();
add();
// counter == 1
```
事与愿违，计数器的值是1。有没有其他方法可以决绝这个问题？
JavaScript的内嵌函数可以解决这个问题。

### JavaScript内嵌函数
所有函数都能访问全局变量。
实际上，在JavaScript中，所有函数都能访问他们上一层的作用域。
Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
JavaScript支持嵌套函数。嵌套函数可以访问上一层的函数变量。
```
function add() {
  var counter = 0;
  function plus() { return counter += 1; }
  plus();
  return counter;
}
```
该实例中，内嵌函数plus()可以访问父函数的counter变量。
如果我们能从外部访问plus()函数的话，就能解决计数器困境。
同样我们需要确保counter = 0只会执行一次。
我们需要闭包。

### JavaScript闭包
```
var add = (function () {
    var counter = 0;
    return function () { return counter += 1; }
})();

add();
add();
add();

// counter == 3
```
自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。
add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。
这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。
计数器受匿名函数的作用域保护，只能通过 add 方法修改。
闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。
由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。
所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

```
function f1(){
  var n=999;
  function f2(){
    alert(n);
  }
  return f2;
}
var result=f1();
result(); // 999
```
### 闭包的用途
闭包可用在很多地方。它最大的用处有两个，一个是前面提到的可以读取函数内部变量，另一个就是让这些变量的值始终保持在内存中。
```
function f1(){
  var n = 999;
  nAdd = function() { return n += 1; }
  function f2() {
    alert(n);
  }
  return f2;
}
var result = f1();
result();
nAdd();
result();
```
result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。
为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。
这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。
